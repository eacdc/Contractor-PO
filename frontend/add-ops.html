<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Contractor PO System - Add Ops to Job</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Toggle Switch Styles */
      #jobModeToggle:checked + span {
        background-color: #6366f1;
      }
      #jobModeToggle:checked + span span {
        transform: translateX(26px);
      }
      /* Panel collapse styles */
      .panel-collapsed > .panel-body {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="app-header">
        <div class="brand">
          <div class="brand-logo">CP</div>
          <div class="brand-text">
            <h1>Contractor PO System</h1>
            <p>Add operations to a specific job.</p>
          </div>
        </div>
        <a href="home.html" class="home-btn">Home</a>
      </header>

      <main class="app-main app-main--home">
        <section class="intro">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <div>
          <h2>Add Ops to Job</h2>
          <p>Search a job by number, review previous ops, and add new ones.</p>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
              <span>Single Job</span>
              <label style="position: relative; display: inline-block; width: 50px; height: 24px;">
                <input type="checkbox" id="jobModeToggle" style="opacity: 0; width: 0; height: 0;">
                <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; border-radius: 24px; transition: 0.4s;">
                  <span style="position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.4s;"></span>
                </span>
              </label>
              <span>Multiple Job</span>
            </div>
          </div>
        </section>

        <!-- Job search -->
        <section class="panel" id="jobSearchPanel">
          <form class="job-search" id="jobSearchForm">
            <div class="field field--inline">
              <label for="jobNumber">Job Number</label>
              <div style="position: relative; display: inline-block; width: 100%;">
                <input
                  id="jobNumber"
                  name="jobNumber"
                  type="text"
                  placeholder="Enter job number (4+ digits)"
                  required
                  autocomplete="off"
                />
                <div id="jobNumberDropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: rgba(15, 23, 42, 0.98); border: 1px solid rgba(129, 140, 248, 0.5); border-radius: 0 0 10px 10px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 20px rgba(0,0,0,0.4);">
                  <!-- Dropdown items will be inserted here -->
                </div>
              </div>
            </div>
            <div class="field field--inline" style="display: none;" id="pullInSeriesField">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="pullInSeriesCheckbox" style="width: auto; margin: 0;" />
                <span>Pull in Series</span>
              </label>
            </div>
            <button class="secondary-btn" type="button" id="addJobBtn" style="display: none;">Add</button>
            <button class="primary-btn" type="submit" id="jobSearchBtn">Search</button>
          </form>
          <p class="inline-warning" id="jobSearchError" style="display: none;"></p>
        </section>

        <!-- Multiple Jobs Container -->
        <section id="multipleJobsContainer" style="display: none;">
          <!-- Expandable job rows will be inserted here -->
        </section>

        <!-- Common Add New Ops Section for Multiple Jobs -->
        <section class="panel panel--collapsible" id="multipleJobsAddOpsSection" style="display: none;">
          <header class="panel-header">
            <h3>Add New Ops (All Jobs)</h3>
          </header>
          <div class="panel-body">
            <div class="table-wrapper">
              <table class="data-table" id="multipleJobsAddOpsTable">
                <thead>
                  <tr>
                    <th>Ops Name</th>
                    <th>Qty / Book</th>
                    <th>Rate</th>
                    <th>Rate / Book</th>
                  </tr>
                </thead>
                <tbody id="multipleJobsAddOpsBody">
                  <tr class="ops-row">
                    <td>
                      <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
                    </td>
                    <td>
                      <input type="text" name="qtyBook" />
                    </td>
                    <td>
                      <input type="number" name="rate" value="1" readonly />
                    </td>
                    <td>
                      <input type="number" name="rateBook" value="1" readonly />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="button-row">
              <button class="secondary-btn" type="button" id="multipleJobsAddOpsRowBtn">
                Add
              </button>
              <button class="primary-btn primary-btn--sm" type="button" id="multipleJobsSaveOpsBtn">
                Save to All Jobs
              </button>
            </div>

            <p class="inline-warning" id="multipleJobsAddOpsWarning"></p>
          </div>
        </section>

        <!-- Section 1: Job details -->
        <section class="panel panel--collapsible">
          <header class="panel-header">
            <h3>Job Details</h3>
          </header>
          <div class="panel-body job-details-grid">
            <div class="field">
              <label for="clientName">Client Name</label>
              <input id="clientName" name="clientName" type="text" readonly />
            </div>
            <div class="field">
              <label for="jobTitle">Job Title</label>
              <input id="jobTitle" name="jobTitle" type="text" readonly />
            </div>
            <div class="field">
              <label for="qty">Qty</label>
              <input id="qty" name="qty" type="number" readonly />
            </div>
            <div class="field">
              <label for="productCat">Product Cat</label>
              <input id="productCat" name="productCat" type="text" readonly />
            </div>
            <div class="field">
              <label for="unitPrice">Unit Price</label>
              <input id="unitPrice" name="unitPrice" type="text" readonly />
            </div>
          </div>
        </section>

        <!-- Section 2: Previous ops -->
        <section class="panel panel--collapsible">
          <header class="panel-header">
            <h3>Previous Ops</h3>
          </header>
          <div class="panel-body">
            <div class="table-wrapper">
              <table class="data-table" id="prevOpsTable">
                <thead>
                  <tr id="prevOpsHeader">
                    <th>Ops</th>
                    <th>Completed Qty</th>
                  </tr>
                </thead>
                <tbody id="prevOpsBody">
                  <tr>
                    <td>-</td>
                    <td>-</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>

        <!-- Section 3: Add new ops -->
        <section class="panel panel--collapsible" id="addNewOpsSection">
          <header class="panel-header">
            <h3>Add New Ops</h3>
          </header>
          <div class="panel-body">
            <div class="table-wrapper">
              <table class="data-table" id="addOpsTable">
                <thead>
                  <tr>
                    <th>Ops Name</th>
                    <th>Qty / Book</th>
                    <th>Rate</th>
                    <th>Rate / Book</th>
                  </tr>
                </thead>
                <tbody id="addOpsBody">
                  <tr class="ops-row">
                    <td>
                      <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
                    </td>
                    <td>
                      <input type="text" name="qtyBook" />
                    </td>
                    <td>
                      <input type="number" name="rate" value="1" readonly />
                    </td>
                    <td>
                      <input type="number" name="rateBook" value="1" readonly />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="button-row">
              <button class="secondary-btn" type="button" id="addOpsRowBtn">
                Add
              </button>
              <button class="primary-btn primary-btn--sm" type="button" id="saveOpsBtn">
                Save
              </button>
            </div>

            <p class="inline-warning" id="addOpsWarning"></p>
          </div>
        </section>
      </main>

      <!-- Single datalist for all ops dropdowns -->
      <datalist id="opsList"></datalist>

      <footer class="app-footer">
        <span>Contractor PO System</span>
        <span class="divider">â€¢</span>
        <span>Add Ops to Job</span>
      </footer>
    </div>

    <script type="module">
      import { jobsAPI, operationsAPI, seriesAPI } from './api.js';

      let currentJobId = null;
      let allOperations = [];
      let hasSearchedJob = false; // Track if a job has been searched
      let isMultipleJobMode = false; // Track single/multiple job mode
      let multipleJobs = []; // Array to store multiple job data
      let currentSeriesId = null; // Store series ID when pulling in a series

      // Collapsible panels
      document.querySelectorAll(".panel--collapsible .panel-header").forEach((header) => {
        header.addEventListener("click", () => {
          const panel = header.closest(".panel--collapsible");
          panel?.classList.toggle("panel-collapsed");
        });
      });

      // Helper: Get currently selected op names/IDs from "Add New Ops" rows
      function getCurrentlySelectedOpNames() {
        const selected = new Set();
        // Check single job section
        const singleJobRows = document.querySelectorAll('#addOpsBody .ops-row');
        singleJobRows.forEach(row => {
          const input = row.querySelector('input[name="opsName"]');
          if (input && input.value) {
            selected.add(input.value);
          }
        });
        // Check multiple jobs section
        const multipleJobsRows = document.querySelectorAll('#multipleJobsAddOpsBody .ops-row');
        multipleJobsRows.forEach(row => {
          const input = row.querySelector('input[name="opsName"]');
          if (input && input.value) {
            selected.add(input.value);
          }
        });
        return selected;
      }

      // Helper: Populate datalist with available operations
      function populateDatalist() {
        const datalist = document.getElementById('opsList');
        if (!datalist) return;
        
        datalist.innerHTML = '';
        
        allOperations.forEach(op => {
          const option = document.createElement('option');
          option.value = op.opsName;
          option.dataset.opId = op._id;
          datalist.appendChild(option);
        });
      }

      // Helper: Find operation by name or ID
      function findOperationByNameOrId(value) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/3a23d043-9df2-40a4-abfb-c396acbfe70e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'add-ops.html:307',message:'findOperationByNameOrId ENTRY',data:{searchValue:value,allOpsCount:allOperations?.length,allOpsNames:allOperations?.map(o=>o.opsName)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
        // #endregion
        if (!value) return null;
        
        // First try to find by ID (normalize to string for comparison)
        const valueStr = String(value);
        let operation = allOperations.find(op => String(op._id) === valueStr);
        
        // #region agent log
        if (operation) {
          fetch('http://127.0.0.1:7243/ingest/3a23d043-9df2-40a4-abfb-c396acbfe70e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'add-ops.html:312',message:'Found by ID',data:{searchValue:value,foundOpsName:operation.opsName},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
        }
        // #endregion
        
        // If not found by ID, try to find by name (case-insensitive)
        if (!operation) {
          const valueTrimmed = value.trim();
          operation = allOperations.find(op => op.opsName.toLowerCase() === valueTrimmed.toLowerCase());
          // #region agent log
          if (operation) {
            fetch('http://127.0.0.1:7243/ingest/3a23d043-9df2-40a4-abfb-c396acbfe70e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'add-ops.html:316',message:'Found by name (case-insensitive)',data:{searchValue:value,foundOpsName:operation.opsName,dbOpsName:operation.opsName},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
          } else {
            fetch('http://127.0.0.1:7243/ingest/3a23d043-9df2-40a4-abfb-c396acbfe70e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'add-ops.html:316',message:'NOT FOUND by name',data:{searchValue:value,allOpsNames:allOperations?.map(o=>o.opsName)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
          }
          // #endregion
        }
        
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/3a23d043-9df2-40a4-abfb-c396acbfe70e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'add-ops.html:318',message:'findOperationByNameOrId EXIT',data:{searchValue:value,found:!!operation,foundOpsName:operation?.opsName},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
        // #endregion
        return operation;
      }

      // Load operations for datalist
      async function loadOperations() {
        try {
          allOperations = await operationsAPI.getAll();
          populateDatalist();
          updateAddButtonVisibility();
          
          // Also initialize multiple jobs section if it's visible
          const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
          if (multipleJobsAddOpsSection && multipleJobsAddOpsSection.style.display !== 'none') {
            initializeMultipleJobsAddOpsSection();
          }
        } catch (error) {
          console.error('Error loading operations:', error);
        }
      }

      // Refresh all inputs in "Add New Ops" section (datalist is shared, so just update visibility)
      function refreshAllDropdowns() {
        // Datalist is shared, so we just need to update visibility
        updateAddButtonVisibility();
      }

      // Check if there are any available operations left to add
      function getAvailableOperationsCount() {
        if (!allOperations || allOperations.length === 0) {
          return 0;
        }
        
        // Since users can now type custom names, we always show the add button
        // if there are any operations loaded (they can always add custom ones)
        return allOperations.length;
      }

      // Update visibility of Add button and Add New Ops section
      function updateAddButtonVisibility() {
        const addBtn = document.getElementById('addOpsRowBtn');
        const addNewOpsSection = document.getElementById('addNewOpsSection');
        const availableCount = getAvailableOperationsCount();
        
        // Hide Add button if no operations available (only if we have operations loaded)
        if (addBtn) {
          if (allOperations.length > 0 && availableCount === 0) {
            addBtn.style.display = 'none';
          } else {
            addBtn.style.display = '';
          }
        }
        
        // Hide entire section only if:
        // 1. A job has been searched (hasSearchedJob === true)
        // 2. AND no operations available
        // 3. AND no rows with entered ops
        if (addNewOpsSection) {
          const rows = document.querySelectorAll('#addOpsBody .ops-row');
          const hasEnteredOps = Array.from(rows).some(row => {
            const input = row.querySelector('input[name="opsName"]');
            return input && input.value;
          });
          
          // Only hide if job has been searched AND no available ops AND no entered ops
          if (hasSearchedJob && allOperations.length === 0 && !hasEnteredOps) {
            addNewOpsSection.style.display = 'none';
          } else {
            addNewOpsSection.style.display = '';
          }
        }
      }

      // Helper: validate qty/book based on operation type
      function validateQtyBook(qtyValue, operation) {
        if (!operation) return { valid: false, message: 'Operation not found' };
        
        const qty = parseFloat(qtyValue);
        
        // Check if it's a valid number
        if (isNaN(qty) || qtyValue.trim() === '') {
          return { valid: false, message: `Qty / Book must be a valid number for operation "${operation.opsName}"` };
        }
        
        // Only validate 1:1 type, validations for 1/x and 1*x are removed
        if (operation.type === '1:1') {
          if (qty !== 1) {
            return { valid: false, message: `Qty / Book must be exactly 1 for operation "${operation.opsName}"` };
          }
        }
        
        return { valid: true };
      }

      // Helper: update column header based on selected operations
      function updateColumnHeader(tableId) {
        const table = document.getElementById(tableId);
        if (!table) return;
        
        const headerCell = table.querySelector('thead th:nth-child(2)'); // Second column (Qty/Book)
        if (!headerCell) return;
        
        const tbody = table.querySelector('tbody');
        if (!tbody) return;
        
        const rows = tbody.querySelectorAll('.ops-row');
        let headerText = 'Qty / Book'; // Default
        let hasOneX = false;
        let hasOneToOneOrOneX = false;
        
        // Check all entered operations to determine header
        for (const row of rows) {
          const opsInput = row.querySelector('input[name="opsName"]');
          if (opsInput && opsInput.value) {
            const operation = findOperationByNameOrId(opsInput.value);
            if (operation) {
              if (operation.type === '1/x') {
                hasOneX = true;
              } else if (operation.type === '1:1' || operation.type === '1*x') {
                hasOneToOneOrOneX = true;
              }
            }
          }
        }
        
        // Determine header text: 1/x takes priority if present
        if (hasOneX) {
          headerText = 'Books / Ops';
        } else if (hasOneToOneOrOneX) {
          headerText = 'Ops / Book';
        }
        
        headerCell.textContent = headerText;
      }

      // Helper: update rate and rate/book for a given row
      function updateRowPricing(row) {
        if (!row) return;

        const opsInput = row.querySelector('input[name="opsName"]');
        const qtyInput = row.querySelector('input[name="qtyBook"]');
        const rateInput = row.querySelector('input[name="rate"]');
        const rateBookInput = row.querySelector('input[name="rateBook"]');

        if (!opsInput || !rateInput || !rateBookInput) return;

        // Ensure rate fields are not editable by user
        rateInput.readOnly = true;
        rateBookInput.readOnly = true;

        const opsValue = opsInput.value;
        const operation = findOperationByNameOrId(opsValue);

        // Default ratePerUnit to 0 if not found (allows custom operations with default rate)
        const ratePerUnit = operation ? Number(operation.ratePerUnit || 0) : 0;

        // Configure qty/book behavior based on operation type
        if (qtyInput) {
          qtyInput.readOnly = false;

          if (operation) {
            if (operation.type === '1:1') {
              // Fixed 1, not editable
              qtyInput.value = 1;
              qtyInput.readOnly = true;
            } else if (operation.type === '1*x') {
              // User can type anything, keep blank initially
              // Don't set default value
            } else if (operation.type === '1/x') {
              // User can type anything, keep blank initially
              // Don't set default value
            }
          }
        }

        rateInput.value = ratePerUnit;

        // Calculate rate/book based on operation type
        const qty = qtyInput && qtyInput.value ? Number(qtyInput.value) : 0;
        if (operation && operation.type === '1/x' && qty > 0) {
          // For 1/x: rate/book = rate * (1 / booksPerOps)
          rateBookInput.value = (ratePerUnit * (1 / qty)).toFixed(2);
        } else if (qty > 0) {
          // For 1:1 and 1*x: rate/book = rate * qty
          rateBookInput.value = (qty * ratePerUnit).toFixed(2);
        } else {
          rateBookInput.value = '';
        }
      }

      // Job search
      const jobSearchForm = document.getElementById('jobSearchForm');
      const jobSearchError = document.getElementById('jobSearchError');
      const jobNumberInput = document.getElementById('jobNumber');
      const jobNumberDropdown = document.getElementById('jobNumberDropdown');
      let searchTimeout = null;

      // Handle job number input - search when 4+ digits entered
      jobNumberInput.addEventListener('input', async (e) => {
        const value = e.target.value.trim();
        
        // Clear previous timeout
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }

        // Hide dropdown if less than 4 characters
        if (value.length < 4) {
          jobNumberDropdown.style.display = 'none';
          return;
        }

        // Debounce search (wait 300ms after user stops typing)
        searchTimeout = setTimeout(async () => {
          try {
            console.log('ðŸ” [FRONTEND] Searching job numbers for:', value);
            const jobNumbers = await jobsAPI.searchJobNumbers(value);
            console.log('ðŸ” [FRONTEND] Received jobNumbers:', jobNumbers);
            console.log('ðŸ” [FRONTEND] jobNumbers type:', typeof jobNumbers, 'isArray:', Array.isArray(jobNumbers));
            
            if (jobNumbers && jobNumbers.length > 0) {
              // Populate dropdown
              jobNumberDropdown.innerHTML = '';
              jobNumbers.forEach(jobNum => {
                const item = document.createElement('div');
                item.style.padding = '10px 14px';
                item.style.cursor = 'pointer';
                item.style.borderBottom = '1px solid rgba(55, 65, 81, 0.5)';
                item.style.color = '#f9fafb';
                item.style.fontSize = '0.9rem';
                item.textContent = jobNum;
                item.addEventListener('mouseenter', () => {
                  item.style.backgroundColor = 'rgba(79, 70, 229, 0.3)';
                });
                item.addEventListener('mouseleave', () => {
                  item.style.backgroundColor = 'transparent';
                });
                item.addEventListener('click', () => {
                  jobNumberInput.value = jobNum;
                  jobNumberDropdown.style.display = 'none';
                  // Trigger job details fetch
                  fetchJobDetails(jobNum);
                });
                jobNumberDropdown.appendChild(item);
              });
              jobNumberDropdown.style.display = 'block';
              console.log('ðŸ” [FRONTEND] Dropdown populated with', jobNumbers.length, 'items');
            } else {
              console.log('ðŸ” [FRONTEND] No job numbers found or empty array');
              jobNumberDropdown.style.display = 'none';
            }
          } catch (error) {
            console.error('âŒ [FRONTEND] Error searching job numbers:', error);
            jobNumberDropdown.style.display = 'none';
          }
        }, 300);
      });

      // Hide dropdown when clicking outside
      document.addEventListener('click', (e) => {
        const jobSearchPanel = jobSearchForm.closest('.panel');
        if (jobSearchPanel && !jobSearchPanel.contains(e.target)) {
          jobNumberDropdown.style.display = 'none';
        }
      });

      // Function to fetch job details from MSSQL
      async function fetchJobDetails(jobNumber) {
        try {
          const jobDetails = await jobsAPI.getJobDetails(jobNumber);
          
          // Populate job details section
          document.getElementById('clientName').value = jobDetails.clientName || '';
          document.getElementById('jobTitle').value = jobDetails.jobTitle || '';
          document.getElementById('qty').value = jobDetails.qty || 0;
          document.getElementById('productCat').value = jobDetails.productCat || '';
          document.getElementById('unitPrice').value = (jobDetails.unitPrice || 0).toFixed(2);
        } catch (error) {
          console.error('Error fetching job details:', error);
          // Fallback to default values if error
          document.getElementById('clientName').value = '';
          document.getElementById('jobTitle').value = '';
          document.getElementById('qty').value = 0;
          document.getElementById('productCat').value = '';
          document.getElementById('unitPrice').value = '0.00';
        }
      }

      jobSearchForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const jobNumber = jobNumberInput.value.trim();
        jobSearchError.style.display = 'none';
        jobNumberDropdown.style.display = 'none';

        if (!jobNumber) {
          jobSearchError.textContent = 'Please enter a job number.';
          jobSearchError.style.display = 'block';
          return;
        }

        try {
          // First fetch job details from MSSQL
          await fetchJobDetails(jobNumber);

          // Then search for previous ops from JobopsMaster
          const result = await jobsAPI.search(jobNumber);
          // Not using Job collection anymore, so currentJobId not needed
          currentJobId = null;
          
          // Mark that a job has been searched
          hasSearchedJob = true;

          // Populate previous ops from Contractor_WD summary (if available)
          const headerRow = document.getElementById('prevOpsHeader');
          const prevOpsBody = document.getElementById('prevOpsBody');

          headerRow.innerHTML = '';
          prevOpsBody.innerHTML = '';

          const previousOps = result.previousOps;

          // Refresh all dropdowns (show all operations)
          refreshAllDropdowns();
          // Update visibility of Add button and section
          updateAddButtonVisibility();

          if (
            previousOps &&
            Array.isArray(previousOps.operations) &&
            previousOps.operations.length > 0
          ) {
            // Header: Ops + one column per contractor (if any)
            const opsTh = document.createElement('th');
            opsTh.textContent = 'Ops';
            headerRow.appendChild(opsTh);

            if (
              previousOps.contractors &&
              Array.isArray(previousOps.contractors) &&
              previousOps.contractors.length > 0
            ) {
              // Show one column per contractor
              previousOps.contractors.forEach(c => {
                const th = document.createElement('th');
                th.textContent = `${c.name} (Completed Qty)`;
                headerRow.appendChild(th);
              });

              // Add Pending column header
              const pendingTh = document.createElement('th');
              pendingTh.textContent = 'Pending';
              headerRow.appendChild(pendingTh);

              // Rows: each op, with qty per contractor + pending
              previousOps.operations.forEach(op => {
                const row = document.createElement('tr');
                let cellsHtml = `<td>${op.opsName}</td>`;

                previousOps.contractors.forEach(c => {
                  const qty =
                    (op.quantitiesByContractor &&
                      op.quantitiesByContractor[c.contractorId]) ||
                    0;
                  cellsHtml += `<td>${qty}</td>`;
                });

                // Add pending quantity
                const pending = op.pending !== undefined ? op.pending : (op.totalOpsQty || 0);
                cellsHtml += `<td>${pending}</td>`;

                row.innerHTML = cellsHtml;
                prevOpsBody.appendChild(row);
              });
            } else {
              // Operations exist but no contractors have done work yet
              const completedTh = document.createElement('th');
              completedTh.textContent = 'Completed Qty';
              headerRow.appendChild(completedTh);
              
              const pendingTh = document.createElement('th');
              pendingTh.textContent = 'Pending';
              headerRow.appendChild(pendingTh);

              previousOps.operations.forEach(op => {
                const row = document.createElement('tr');
                const pending = op.pending !== undefined ? op.pending : (op.totalOpsQty || 0);
                row.innerHTML = `<td>${op.opsName}</td><td>0</td><td>${pending}</td>`;
                prevOpsBody.appendChild(row);
              });
            }
          } else {
            // No previous work: show basic header and keep body empty
            headerRow.innerHTML = '<th>Ops</th><th>Completed Qty</th><th>Pending</th>';
            prevOpsBody.innerHTML = '';
          }

          // Do not show any error if request succeeded
          jobSearchError.textContent = '';
          jobSearchError.style.display = 'none';
        } catch (error) {
          // Try to fetch job details from MSSQL even if previous ops search failed
          try {
            await fetchJobDetails(jobNumber);
          } catch (detailsError) {
            console.error('Error fetching job details:', detailsError);
            // Clear job details if fetch fails
            document.getElementById('clientName').value = '';
            document.getElementById('jobTitle').value = '';
            document.getElementById('qty').value = 0;
            document.getElementById('productCat').value = '';
            document.getElementById('unitPrice').value = 0;
          }

          // For previous ops, when job is not found we reset to
          // a table with one row saying "No previous ops found".
          const headerRow = document.getElementById('prevOpsHeader');
          const prevOpsBody = document.getElementById('prevOpsBody');
          headerRow.innerHTML = '<th>Ops</th><th>Completed Qty</th><th>Pending</th>';
          prevOpsBody.innerHTML = '<tr><td colspan="3">No previous ops found</td></tr>';

          // Mark that a job has been searched (even if not found)
          hasSearchedJob = true;
          
          // Refresh all dropdowns (show all operations)
          refreshAllDropdowns();
          // Update visibility of Add button and section
          updateAddButtonVisibility();

          // Do not show "job not found" error in this case
          jobSearchError.textContent = '';
          jobSearchError.style.display = 'none';
        }
      });

      // Add new ops row
      const addRowBtn = document.getElementById("addOpsRowBtn");
      const opsBody = document.getElementById("addOpsBody");
      const addOpsWarning = document.getElementById("addOpsWarning");

      if (addRowBtn && opsBody) {
        addRowBtn.addEventListener("click", async () => {
          const rows = opsBody.querySelectorAll(".ops-row");
          const lastRow = rows[rows.length - 1];
          if (!lastRow) return;

          const lastOpsInput = lastRow.querySelector('input[name="opsName"]');
          const lastQty = lastRow.querySelector('input[name="qtyBook"]');
          const lastRate = lastRow.querySelector('input[name="rate"]');
          const lastRateBook = lastRow.querySelector('input[name="rateBook"]');

          const isFilled =
            lastOpsInput &&
            lastOpsInput.value.trim() !== "" &&
            lastQty &&
            lastQty.value.trim() !== "" &&
            lastRate &&
            lastRate.value.trim() !== "" &&
            lastRateBook &&
            lastRateBook.value.trim() !== "";

          if (!isFilled) {
            if (addOpsWarning) {
              addOpsWarning.textContent = "Please fill Ops Name, Qty / Book, Rate, and Rate / Book before adding a new row.";
            }
            return;
          }

          if (addOpsWarning) {
            addOpsWarning.textContent = "";
          }

          const templateRow = rows[0];
          if (!templateRow) return;

          const clone = templateRow.cloneNode(true);

          // Reset values in cloned row
          const opsInput = clone.querySelector('input[name="opsName"]');
          const qtyInput = clone.querySelector('input[name="qtyBook"]');
          const rateInput = clone.querySelector('input[name="rate"]');
          const rateBookInput = clone.querySelector('input[name="rateBook"]');

          if (opsInput) {
            opsInput.value = "";
          }
          if (qtyInput) qtyInput.value = "";
          if (rateInput) {
            rateInput.value = "1";
            rateInput.readOnly = true;
          }
          if (rateBookInput) {
            rateBookInput.value = "1";
            rateBookInput.readOnly = true;
          }

          opsBody.appendChild(clone);
          
          // Update visibility after adding new row
          updateAddButtonVisibility();
        });
      }

        // Event delegation: when ops name is entered, auto-populate rate and rate/book
        if (opsBody) {
          opsBody.addEventListener('input', (e) => {
            const target = e.target;
            if (target && target.name === 'opsName') {
              const row = target.closest('.ops-row');
              if (row) {
                const opsValue = target.value.trim();
                // Validate if operation exists in list
                if (opsValue) {
                  const operation = findOperationByNameOrId(opsValue);
                  if (!operation) {
                    // Show warning in the row or in the warning area
                    if (addOpsWarning) {
                      addOpsWarning.textContent = `"${opsValue}" is not in the operations list. Please select from the list.`;
                      addOpsWarning.style.color = "#ef4444";
                    }
                  } else {
                    // Clear warning if operation is found
                    if (addOpsWarning && addOpsWarning.textContent.includes('is not in the operations list')) {
                      addOpsWarning.textContent = "";
                    }
                  }
                } else {
                  // Clear warning if field is empty
                  if (addOpsWarning && addOpsWarning.textContent.includes('is not in the operations list')) {
                    addOpsWarning.textContent = "";
                  }
                }
                
                updateRowPricing(row);
                // Update column header based on entered operations
                updateColumnHeader('addOpsTable');
                // Update visibility after input change
                updateAddButtonVisibility();
              }
            }
          });
          
          // Also validate on blur to catch when user leaves the field
          opsBody.addEventListener('blur', (e) => {
            const target = e.target;
            if (target && target.name === 'opsName') {
              const opsValue = target.value.trim();
              if (opsValue) {
                const operation = findOperationByNameOrId(opsValue);
                if (!operation) {
                  if (addOpsWarning) {
                    addOpsWarning.textContent = `"${opsValue}" is not in the operations list. Please select from the list.`;
                    addOpsWarning.style.color = "#ef4444";
                  }
                }
              }
            }
          }, true);

        // When qty / book changes, recompute rate / book using current rate
        opsBody.addEventListener('input', (e) => {
          const target = e.target;
          if (target && target.name === 'qtyBook') {
            const row = target.closest('.ops-row');
            if (!row) return;

            const qtyInput = row.querySelector('input[name="qtyBook"]');
            const rateInput = row.querySelector('input[name="rate"]');
            const rateBookInput = row.querySelector('input[name="rateBook"]');

            if (!qtyInput || !rateInput || !rateBookInput) return;

            const opsInput = row.querySelector('input[name="opsName"]');
            const opsValue = opsInput ? opsInput.value : null;
            const operation = opsValue
              ? findOperationByNameOrId(opsValue)
              : null;

            // Calculate rate/book based on current qty/book value and operation type
            const qty = qtyInput.value ? parseFloat(qtyInput.value) : 0;
            const rate = rateInput.value ? parseFloat(rateInput.value) : 0;
            
            // Only update rate/book if qty and rate are valid numbers
            if (!isNaN(qty) && !isNaN(rate) && qty > 0) {
              if (operation && operation.type === '1/x') {
                // For 1/x: rate/book = rate * (1 / booksPerOps)
                rateBookInput.value = (rate * (1 / qty)).toFixed(2);
              } else {
                // For 1:1 and 1*x: rate/book = rate * qty
                rateBookInput.value = (qty * rate).toFixed(2);
              }
            } else {
              rateBookInput.value = '';
            }
          }
        });
      }

      // Save operations
      const saveBtn = document.getElementById("saveOpsBtn");
      if (saveBtn) {
        saveBtn.addEventListener("click", async () => {
          const jobNumberInput = document.getElementById('jobNumber');
          const jobNumber = jobNumberInput ? jobNumberInput.value.trim() : '';

          if (!jobNumber) {
            addOpsWarning.textContent = "Please search for a job first.";
            return;
          }

          const rows = opsBody.querySelectorAll(".ops-row");
          const operations = [];

          // Validate all rows before processing
          for (const row of rows) {
            const opsInput = row.querySelector('input[name="opsName"]');
            const qtyInput = row.querySelector('input[name="qtyBook"]');
            const rateInput = row.querySelector('input[name="rate"]');
            const rateBookInput = row.querySelector('input[name="rateBook"]');

            if (opsInput?.value && qtyInput?.value && rateInput?.value && rateBookInput?.value) {
              // Find the operation to validate qty/book
              const opsValue = opsInput.value.trim();
              const operation = findOperationByNameOrId(opsValue);
              
              // Check if operation exists in the list
              if (!operation) {
                addOpsWarning.textContent = `Operation "${opsValue}" is not in the list. Please select an operation from the list.`;
                return; // Stop saving if operation not found
              }
              
              // Validate qty/book based on operation type
              const validation = validateQtyBook(qtyInput.value, operation);
              if (!validation.valid) {
                addOpsWarning.textContent = validation.message;
                return; // Stop saving if validation fails
              }
              
              // Use operation ID (operation must exist at this point)
              operations.push({
                operationId: operation._id,
                qtyPerBook: parseFloat(qtyInput.value),
                rate: parseFloat(rateInput.value),
                ratePerBook: parseFloat(rateBookInput.value)
              });
            }
          }

          if (operations.length === 0) {
            addOpsWarning.textContent = "Please add at least one operation.";
            return;
          }

          // Collect current job details from the UI so that if the job
          // does not yet exist, the backend can create it.
          const clientNameInput = document.getElementById('clientName');
          const jobTitleInput = document.getElementById('jobTitle');
          const qtyInput = document.getElementById('qty');
          const productCatInput = document.getElementById('productCat');
          const unitPriceInput = document.getElementById('unitPrice');

          const extraJobData = {
            clientName: clientNameInput ? clientNameInput.value : '',
            jobTitle: jobTitleInput ? jobTitleInput.value : '',
            qty: qtyInput && qtyInput.value ? Number(qtyInput.value) : 0,
            productCat: productCatInput ? productCatInput.value : '',
            unitPrice: unitPriceInput && unitPriceInput.value ? Number(unitPriceInput.value) : 0
          };

          try {
            await jobsAPI.saveJobOpsMaster(jobNumber, operations, extraJobData);
            addOpsWarning.textContent = "";
            alert('Operations saved successfully!');
            
            // After successful save, clear the entire form/page state
            if (jobNumberInput) jobNumberInput.value = '';

            // Clear job details
            if (clientNameInput) clientNameInput.value = '';
            if (jobTitleInput) jobTitleInput.value = '';
            if (qtyInput) qtyInput.value = '';
            if (productCatInput) productCatInput.value = '';
            if (unitPriceInput) unitPriceInput.value = '';

            // Reset Previous Ops table
            const headerRow = document.getElementById('prevOpsHeader');
            const prevOpsBody = document.getElementById('prevOpsBody');
            if (headerRow) headerRow.innerHTML = '<th>Ops</th><th>Completed Qty</th>';
            if (prevOpsBody) prevOpsBody.innerHTML = '';

            // Reset job search flag
            hasSearchedJob = false;

            // Reset Add New Ops table to a single empty row
            if (opsBody) {
              opsBody.innerHTML = '';
              const baseRow = document.createElement('tr');
              baseRow.classList.add('ops-row');
              baseRow.innerHTML = `
                <td>
                  <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
                </td>
                <td>
                  <input type="text" name="qtyBook" />
                </td>
                <td>
                  <input type="number" name="rate" value="1" readonly />
                </td>
                <td>
                  <input type="number" name="rateBook" value="1" readonly />
                </td>
              `;
              opsBody.appendChild(baseRow);
              // Datalist is already populated, no need to reload
              // Update visibility after reset
              updateAddButtonVisibility();
            }
          } catch (error) {
            addOpsWarning.textContent = error.message || 'Failed to save operations.';
          }
        });
      }

      // Function to clear single job form
      function clearSingleJobForm() {
        // Clear job number input
        if (jobNumberInput) jobNumberInput.value = '';
        
        // Clear job details
        const clientNameInput = document.getElementById('clientName');
        const jobTitleInput = document.getElementById('jobTitle');
        const qtyInput = document.getElementById('qty');
        const productCatInput = document.getElementById('productCat');
        const unitPriceInput = document.getElementById('unitPrice');
        
        if (clientNameInput) clientNameInput.value = '';
        if (jobTitleInput) jobTitleInput.value = '';
        if (qtyInput) qtyInput.value = '';
        if (productCatInput) productCatInput.value = '';
        if (unitPriceInput) unitPriceInput.value = '';
        
        // Clear previous ops table
        const headerRow = document.getElementById('prevOpsHeader');
        const prevOpsBody = document.getElementById('prevOpsBody');
        if (headerRow) headerRow.innerHTML = '<th>Ops</th><th>Completed Qty</th>';
        if (prevOpsBody) prevOpsBody.innerHTML = '<tr><td>-</td><td>-</td></tr>';
        
        // Clear add ops table
        if (opsBody) {
          opsBody.innerHTML = '';
          const baseRow = document.createElement('tr');
          baseRow.classList.add('ops-row');
          baseRow.innerHTML = `
            <td>
              <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
            </td>
            <td>
              <input type="text" name="qtyBook" />
            </td>
            <td>
              <input type="number" name="rate" value="1" readonly />
            </td>
            <td>
              <input type="number" name="rateBook" value="1" readonly />
            </td>
          `;
          opsBody.appendChild(baseRow);
          // Datalist is already populated, no need to do anything
        }
        
        // Clear warnings
        if (jobSearchError) {
          jobSearchError.textContent = '';
          jobSearchError.style.display = 'none';
        }
        if (addOpsWarning) addOpsWarning.textContent = '';
        
        // Reset flags
        hasSearchedJob = false;
        currentJobId = null;
        
        // Hide dropdown
        if (jobNumberDropdown) jobNumberDropdown.style.display = 'none';
      }
      
      // Toggle between single and multiple job mode
      const jobModeToggle = document.getElementById('jobModeToggle');
      const addJobBtn = document.getElementById('addJobBtn');
      const multipleJobsContainer = document.getElementById('multipleJobsContainer');
      
      if (jobModeToggle) {
        jobModeToggle.addEventListener('change', (e) => {
          isMultipleJobMode = e.target.checked;
          
          // Find the sections to hide/show - these are panel--collapsible sections that are direct children of main
          // but NOT the multipleJobsContainer
          const mainElement = document.querySelector('main.app-main');
          const sectionsToToggle = [];
          
          if (mainElement) {
            Array.from(mainElement.children).forEach(section => {
              if (section.tagName === 'SECTION' && 
                  section.classList.contains('panel--collapsible') && 
                  section.id !== 'multipleJobsContainer' &&
                  section.id !== 'multipleJobsAddOpsSection') {
                sectionsToToggle.push(section);
              }
            });
          }
          
          if (isMultipleJobMode) {
            // Switch to multiple job mode
            // Reset all state variables FIRST
            hasSearchedJob = false;
            currentJobId = null;
            currentSeriesId = null;
            multipleJobs = [];
            
            // Clear job number input and dropdown
            if (jobNumberInput) {
              jobNumberInput.value = '';
            }
            const jobNumberDropdown = document.getElementById('jobNumberDropdown');
            if (jobNumberDropdown) {
              jobNumberDropdown.innerHTML = '';
              jobNumberDropdown.style.display = 'none';
            }
            
            // Clear all warnings
            const jobSearchError = document.getElementById('jobSearchError');
            if (jobSearchError) {
              jobSearchError.textContent = '';
              jobSearchError.style.display = 'none';
            }
            
            // Clear single job form completely
            clearSingleJobForm();
            
            // Collapse and hide all single job panels
            sectionsToToggle.forEach(section => {
              section.classList.add('panel-collapsed');
              section.style.display = 'none';
            });
            
            // Clear multiple jobs container - remove all child nodes
            if (multipleJobsContainer) {
              while (multipleJobsContainer.firstChild) {
                multipleJobsContainer.removeChild(multipleJobsContainer.firstChild);
              }
              multipleJobsContainer.style.display = '';
            }
            
            // Clear multiple jobs Add Ops body
            const multipleJobsAddOpsBody = document.getElementById('multipleJobsAddOpsBody');
            if (multipleJobsAddOpsBody) {
              multipleJobsAddOpsBody.innerHTML = '';
              // Add base row
              const baseRow = document.createElement('tr');
              baseRow.classList.add('ops-row');
              baseRow.innerHTML = `
                <td>
                  <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
                </td>
                <td>
                  <input type="text" name="qtyBook" />
                </td>
                <td>
                  <input type="number" name="rate" value="1" readonly />
                </td>
                <td>
                  <input type="number" name="rateBook" value="1" readonly />
                </td>
              `;
              multipleJobsAddOpsBody.appendChild(baseRow);
            }
            
            // Clear multiple jobs warning
            const multipleJobsAddOpsWarning = document.getElementById('multipleJobsAddOpsWarning');
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = '';
            }
            
            // Show Pull in Series checkbox
            const pullInSeriesField = document.getElementById('pullInSeriesField');
            if (pullInSeriesField) pullInSeriesField.style.display = '';
            // Clear Pull in Series checkbox state
            const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
            if (pullInSeriesCheckbox) pullInSeriesCheckbox.checked = false;
            
            // Update button visibility and text
            addJobBtn.style.display = '';
            const jobSearchBtn = document.getElementById('jobSearchBtn');
            if (jobSearchBtn) jobSearchBtn.style.display = 'none';
            updateMultipleJobsAddButtonText();
            
            // Hide common Add New Ops section
            const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
            if (multipleJobsAddOpsSection) {
              multipleJobsAddOpsSection.style.display = 'none';
              multipleJobsAddOpsSection.classList.add('panel-collapsed');
            }
          } else {
            // Switch to single job mode
            // Reset all state variables FIRST
            hasSearchedJob = false;
            currentJobId = null;
            currentSeriesId = null;
            multipleJobs = [];
            
            // Clear job number input and dropdown
            if (jobNumberInput) {
              jobNumberInput.value = '';
            }
            const jobNumberDropdown = document.getElementById('jobNumberDropdown');
            if (jobNumberDropdown) {
              jobNumberDropdown.innerHTML = '';
              jobNumberDropdown.style.display = 'none';
            }
            
            // Clear all warnings
            const jobSearchError = document.getElementById('jobSearchError');
            if (jobSearchError) {
              jobSearchError.textContent = '';
              jobSearchError.style.display = 'none';
            }
            
            // Clear multiple jobs container - remove all child nodes
            if (multipleJobsContainer) {
              while (multipleJobsContainer.firstChild) {
                multipleJobsContainer.removeChild(multipleJobsContainer.firstChild);
              }
              multipleJobsContainer.style.display = 'none';
            }
            
            // Clear multiple jobs Add Ops body
            const multipleJobsAddOpsBody = document.getElementById('multipleJobsAddOpsBody');
            if (multipleJobsAddOpsBody) {
              multipleJobsAddOpsBody.innerHTML = '';
              // Add base row
              const baseRow = document.createElement('tr');
              baseRow.classList.add('ops-row');
              baseRow.innerHTML = `
                <td>
                  <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
                </td>
                <td>
                  <input type="text" name="qtyBook" />
                </td>
                <td>
                  <input type="number" name="rate" value="1" readonly />
                </td>
                <td>
                  <input type="number" name="rateBook" value="1" readonly />
                </td>
              `;
              multipleJobsAddOpsBody.appendChild(baseRow);
            }
            
            // Clear multiple jobs warning
            const multipleJobsAddOpsWarning = document.getElementById('multipleJobsAddOpsWarning');
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = '';
            }
            
            // Hide Pull in Series checkbox
            const pullInSeriesField = document.getElementById('pullInSeriesField');
            if (pullInSeriesField) pullInSeriesField.style.display = 'none';
            // Clear Pull in Series checkbox state
            const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
            if (pullInSeriesCheckbox) pullInSeriesCheckbox.checked = false;
            
            // Update button visibility and text
            addJobBtn.style.display = 'none';
            const jobSearchBtn = document.getElementById('jobSearchBtn');
            if (jobSearchBtn) jobSearchBtn.style.display = '';
            const addJobBtnReset = document.getElementById('addJobBtn');
            if (addJobBtnReset) addJobBtnReset.textContent = 'Add';
            
            // Clear all single job form fields
            clearSingleJobForm();
            
            // Show single job sections (keep them expanded, don't collapse)
            sectionsToToggle.forEach(section => {
              section.classList.remove('panel-collapsed'); // Remove collapsed class to keep them expanded
              section.style.display = '';
            });
            
            // Hide common Add New Ops section
            const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
            if (multipleJobsAddOpsSection) {
              multipleJobsAddOpsSection.style.display = 'none';
              multipleJobsAddOpsSection.classList.add('panel-collapsed');
            }
          }
        });
      }

      // Helper function to add a single job to multiple jobs list
      async function addJobToMultipleList(jobNumber) {
        // Check if job already exists
        if (multipleJobs.some(job => job.jobNumber === jobNumber)) {
          return false; // Job already exists
        }

        try {
          // Fetch job details
          const jobDetails = await jobsAPI.getJobDetails(jobNumber);
          
          // Create job object
          const jobData = {
            jobNumber,
            jobDetails,
            previousOps: null,
            expanded: false
          };

          // Try to fetch previous ops
          try {
            const result = await jobsAPI.search(jobNumber);
            jobData.previousOps = result.previousOps;
          } catch (error) {
            console.error('Error fetching previous ops:', error);
          }

          // Add to multiple jobs array
          multipleJobs.push(jobData);

          // Create expandable row
          createJobRow(jobData);

          return true; // Successfully added
        } catch (error) {
          console.error(`Error adding job ${jobNumber}:`, error);
          return false; // Failed to add
        }
      }

      // Add job to multiple jobs list
      if (addJobBtn) {
        addJobBtn.addEventListener('click', async () => {
          const jobNumber = jobNumberInput.value.trim();
          const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
          const shouldPullSeries = pullInSeriesCheckbox && pullInSeriesCheckbox.checked;
          
          if (!jobNumber) {
            jobSearchError.textContent = 'Please enter a job number.';
            jobSearchError.style.display = 'block';
            return;
          }

          // Check if job already exists
          if (multipleJobs.some(job => job.jobNumber === jobNumber)) {
            jobSearchError.textContent = 'This job number is already added.';
            jobSearchError.style.display = 'block';
            return;
          }

          try {
            let jobNumbersToAdd = [jobNumber];

            // If "Pull in Series" is checked, search for the series
            if (shouldPullSeries) {
              try {
                const seriesResult = await seriesAPI.searchByJobNumber(jobNumber);
                if (seriesResult.found && seriesResult.jobNumbers && seriesResult.jobNumbers.length > 0) {
                  // Use all job numbers from the series
                  jobNumbersToAdd = seriesResult.jobNumbers;
                  // Store the series ID so we don't create a new series when saving
                  currentSeriesId = seriesResult.seriesId || null;
                  console.log(`Found series with ${jobNumbersToAdd.length} job numbers, series ID: ${currentSeriesId}`);
                }
              } catch (seriesError) {
                console.error('Error searching series:', seriesError);
                // Continue with just the entered job number if series search fails
                currentSeriesId = null; // Clear series ID if search fails
              }
            } else {
              // If not pulling series, clear any existing series ID
              currentSeriesId = null;
            }

            // Add all job numbers (filter out duplicates)
            const existingJobNumbers = new Set(multipleJobs.map(job => job.jobNumber));
            const jobsToAdd = jobNumbersToAdd.filter(jn => !existingJobNumbers.has(jn));
            
            if (jobsToAdd.length === 0) {
              jobSearchError.textContent = 'All job numbers from the series are already added.';
              jobSearchError.style.display = 'block';
              return;
            }

            // Add all jobs
            const addPromises = jobsToAdd.map(jn => addJobToMultipleList(jn));
            const results = await Promise.all(addPromises);
            const successCount = results.filter(r => r === true).length;

            if (successCount > 0) {
              // Show common Add New Ops section (expanded, not collapsed)
              const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
              if (multipleJobsAddOpsSection) {
                multipleJobsAddOpsSection.style.display = '';
                multipleJobsAddOpsSection.classList.remove('panel-collapsed'); // Keep it expanded
                // Initialize the common section - populate dropdowns
                initializeMultipleJobsAddOpsSection();
              }

              // Clear input
              jobNumberInput.value = '';
              jobSearchError.style.display = 'none';
              
              if (shouldPullSeries && successCount > 1) {
                jobSearchError.textContent = `Added ${successCount} job(s) from series.`;
                jobSearchError.style.color = '#4ade80';
                jobSearchError.style.display = 'block';
                setTimeout(() => {
                  jobSearchError.style.display = 'none';
                }, 3000);
              }
            } else {
              jobSearchError.textContent = 'Error fetching job details. Please check the job number(s).';
              jobSearchError.style.display = 'block';
            }
          } catch (error) {
            jobSearchError.textContent = 'Error fetching job details. Please check the job number.';
            jobSearchError.style.display = 'block';
          }
        });
      }

      // Create expandable row for a job
      function createJobRow(jobData) {
        const jobRowId = `job-row-${jobData.jobNumber}`;
        const rowDiv = document.createElement('div');
        rowDiv.id = jobRowId;
        rowDiv.classList.add('panel', 'panel--collapsible');
        rowDiv.style.marginTop = '16px';
        
        // Header with job number
        const header = document.createElement('header');
        header.classList.add('panel-header');
        header.style.cursor = 'pointer';
        header.innerHTML = `<h3>Job: ${jobData.jobNumber}</h3>`;
        
        // Body with job sections
        const body = document.createElement('div');
        body.classList.add('panel-body');
        
        // Make header clickable to expand/collapse
        header.addEventListener('click', () => {
          rowDiv.classList.toggle('panel-collapsed');
          jobData.expanded = !rowDiv.classList.contains('panel-collapsed');
        });
        
        // Job Details Section
        const jobDetailsSection = createJobDetailsSection(jobData);
        body.appendChild(jobDetailsSection);
        
        // Previous Ops Section
        const prevOpsSection = createPreviousOpsSection(jobData);
        body.appendChild(prevOpsSection);
        
        // Don't add individual Add New Ops section - use common one instead
        
        rowDiv.appendChild(header);
        rowDiv.appendChild(body);
        multipleJobsContainer.appendChild(rowDiv);
        
        // Initially collapsed
        rowDiv.classList.add('panel-collapsed');
      }

      // Create job details section for a job
      function createJobDetailsSection(jobData) {
        const section = document.createElement('section');
        section.classList.add('panel', 'panel--collapsible');
        
        const header = document.createElement('header');
        header.classList.add('panel-header');
        header.innerHTML = '<h3>Job Details</h3>';
        
        const body = document.createElement('div');
        body.classList.add('panel-body', 'job-details-grid');
        body.innerHTML = `
          <div class="field">
            <label>Client Name</label>
            <input type="text" value="${jobData.jobDetails.clientName || ''}" readonly />
          </div>
          <div class="field">
            <label>Job Title</label>
            <input type="text" value="${jobData.jobDetails.jobTitle || ''}" readonly />
          </div>
          <div class="field">
            <label>Qty</label>
            <input type="number" value="${jobData.jobDetails.qty || 0}" readonly />
          </div>
          <div class="field">
            <label>Product Cat</label>
            <input type="text" value="${jobData.jobDetails.productCat || ''}" readonly />
          </div>
          <div class="field">
            <label>Unit Price</label>
            <input type="text" value="${(jobData.jobDetails.unitPrice || 0).toFixed(2)}" readonly />
          </div>
        `;
        
        section.appendChild(header);
        section.appendChild(body);
        return section;
      }

      // Create previous ops section for a job
      function createPreviousOpsSection(jobData) {
        const section = document.createElement('section');
        section.classList.add('panel', 'panel--collapsible');
        
        const header = document.createElement('header');
        header.classList.add('panel-header');
        header.innerHTML = '<h3>Previous Ops</h3>';
        
        const body = document.createElement('div');
        body.classList.add('panel-body');
        
        const tableWrapper = document.createElement('div');
        tableWrapper.classList.add('table-wrapper');
        
        const table = document.createElement('table');
        table.classList.add('data-table');
        
        const thead = document.createElement('thead');
        const tbody = document.createElement('tbody');
        
        // Populate previous ops
        if (jobData.previousOps && Array.isArray(jobData.previousOps.operations) && jobData.previousOps.operations.length > 0) {
          const headerRow = document.createElement('tr');
          headerRow.innerHTML = '<th>Ops</th>';
          
          if (jobData.previousOps.contractors && Array.isArray(jobData.previousOps.contractors) && jobData.previousOps.contractors.length > 0) {
            jobData.previousOps.contractors.forEach(c => {
              const th = document.createElement('th');
              th.textContent = `${c.name} (Completed Qty)`;
              headerRow.appendChild(th);
            });
            
            const pendingTh = document.createElement('th');
            pendingTh.textContent = 'Pending';
            headerRow.appendChild(pendingTh);
            
            jobData.previousOps.operations.forEach(op => {
              const row = document.createElement('tr');
              let cellsHtml = `<td>${op.opsName}</td>`;
              
              jobData.previousOps.contractors.forEach(c => {
                const qty = (op.quantitiesByContractor && op.quantitiesByContractor[c.contractorId]) || 0;
                cellsHtml += `<td>${qty}</td>`;
              });
              
              const pending = op.pending !== undefined ? op.pending : (op.totalOpsQty || 0);
              cellsHtml += `<td>${pending}</td>`;
              
              row.innerHTML = cellsHtml;
              tbody.appendChild(row);
            });
          } else {
            headerRow.innerHTML = '<th>Ops</th><th>Completed Qty</th><th>Pending</th>';
            jobData.previousOps.operations.forEach(op => {
              const row = document.createElement('tr');
              const pending = op.pending !== undefined ? op.pending : (op.totalOpsQty || 0);
              row.innerHTML = `<td>${op.opsName}</td><td>0</td><td>${pending}</td>`;
              tbody.appendChild(row);
            });
          }
          
          thead.appendChild(headerRow);
        } else {
          thead.innerHTML = '<tr><th>Ops</th><th>Completed Qty</th><th>Pending</th></tr>';
        }
        
        table.appendChild(thead);
        table.appendChild(tbody);
        tableWrapper.appendChild(table);
        body.appendChild(tableWrapper);
        
        section.appendChild(header);
        section.appendChild(body);
        return section;
      }

      // Initialize common Add New Ops section for multiple jobs
      function initializeMultipleJobsAddOpsSection() {
        const opsBody = document.getElementById('multipleJobsAddOpsBody');
        if (!opsBody) return;
        
        // Ensure operations are loaded
        if (allOperations.length === 0) {
          // Operations not loaded yet, wait a bit and try again
          setTimeout(() => {
            initializeMultipleJobsAddOpsSection();
          }, 200);
          return;
        }
        
        // Clear and create initial row if needed
        if (opsBody.children.length === 0) {
          const baseRow = document.createElement('tr');
          baseRow.classList.add('ops-row');
          baseRow.innerHTML = `
            <td>
              <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
            </td>
            <td>
              <input type="text" name="qtyBook" />
            </td>
            <td>
              <input type="number" name="rate" value="1" readonly />
            </td>
            <td>
              <input type="number" name="rateBook" value="1" readonly />
            </td>
          `;
          opsBody.appendChild(baseRow);
        }
        
        // Datalist is already populated globally, no need to do anything here
      }
      
      // Create add ops section for a job (no longer used, kept for reference)
      function createAddOpsSection(jobData) {
        const section = document.createElement('section');
        section.classList.add('panel', 'panel--collapsible');
        
        const header = document.createElement('header');
        header.classList.add('panel-header');
        header.innerHTML = '<h3>Add New Ops</h3>';
        
        const body = document.createElement('div');
        body.classList.add('panel-body');
        
        const tableWrapper = document.createElement('div');
        tableWrapper.classList.add('table-wrapper');
        
        const table = document.createElement('table');
        table.classList.add('data-table');
        table.innerHTML = `
          <thead>
            <tr>
              <th>Ops Name</th>
              <th>Qty / Book</th>
              <th>Rate</th>
              <th>Rate / Book</th>
            </tr>
          </thead>
          <tbody class="add-ops-body-${jobData.jobNumber}">
            <tr class="ops-row">
              <td>
                <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
              </td>
              <td>
                <input type="text" name="qtyBook" />
              </td>
              <td>
                <input type="number" name="rate" value="1" readonly />
              </td>
              <td>
                <input type="number" name="rateBook" value="1" readonly />
              </td>
            </tr>
          </tbody>
        `;
        
        tableWrapper.appendChild(table);
        body.appendChild(tableWrapper);
        
        const buttonRow = document.createElement('div');
        buttonRow.classList.add('button-row');
        buttonRow.innerHTML = `
          <button class="secondary-btn add-ops-row-btn" data-job="${jobData.jobNumber}">Add</button>
          <button class="primary-btn primary-btn--sm save-ops-btn" data-job="${jobData.jobNumber}">Save</button>
        `;
        body.appendChild(buttonRow);
        
        const warning = document.createElement('p');
        warning.classList.add('inline-warning');
        warning.id = `addOpsWarning-${jobData.jobNumber}`;
        body.appendChild(warning);
        
        section.appendChild(header);
        section.appendChild(body);
        
        // Datalist is already populated globally, no need to initialize
        
        return section;
      }

      // Function to update the ADD button text based on Pull in Series checkbox
      function updateMultipleJobsAddButtonText() {
        const addJobBtn = document.getElementById('addJobBtn');
        const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
        
        if (addJobBtn && pullInSeriesCheckbox) {
          if (pullInSeriesCheckbox.checked) {
            addJobBtn.textContent = 'Search';
          } else {
            addJobBtn.textContent = 'Add';
          }
        }
      }

      // Event handlers for common Add New Ops section in multiple job mode
      const multipleJobsAddOpsRowBtn = document.getElementById('multipleJobsAddOpsRowBtn');
      const multipleJobsSaveOpsBtn = document.getElementById('multipleJobsSaveOpsBtn');
      const multipleJobsAddOpsBody = document.getElementById('multipleJobsAddOpsBody');
      const multipleJobsAddOpsWarning = document.getElementById('multipleJobsAddOpsWarning');
      
      // Add event listener to Pull in Series checkbox to update button text and clear series
      const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
      if (pullInSeriesCheckbox) {
        pullInSeriesCheckbox.addEventListener('change', () => {
          if (isMultipleJobMode) {
            updateMultipleJobsAddButtonText();
            
            // If unchecked, clear the fetched series
            if (!pullInSeriesCheckbox.checked) {
              // Clear series ID
              currentSeriesId = null;
              
              // Clear all jobs from multipleJobs array
              multipleJobs = [];
              
              // Clear the multiple jobs container
              const multipleJobsContainer = document.getElementById('multipleJobsContainer');
              if (multipleJobsContainer) {
                multipleJobsContainer.innerHTML = '';
              }
              
              // Hide the Add New Ops section
              const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
              if (multipleJobsAddOpsSection) {
                multipleJobsAddOpsSection.style.display = 'none';
              }
              
              // Clear job number input
              const jobNumberInput = document.getElementById('jobNumber');
              if (jobNumberInput) {
                jobNumberInput.value = '';
              }
              
              // Clear any error messages
              const jobSearchError = document.getElementById('jobSearchError');
              if (jobSearchError) {
                jobSearchError.textContent = '';
                jobSearchError.style.display = 'none';
              }
            }
          }
        });
      }
      
      // Add row button for common Add New Ops section
      if (multipleJobsAddOpsRowBtn && multipleJobsAddOpsBody) {
        multipleJobsAddOpsRowBtn.addEventListener('click', () => {
          const rows = multipleJobsAddOpsBody.querySelectorAll('.ops-row');
          const lastRow = rows[rows.length - 1];
          if (!lastRow) return;
          
          const lastOpsInput = lastRow.querySelector('input[name="opsName"]');
          const lastQty = lastRow.querySelector('input[name="qtyBook"]');
          const lastRate = lastRow.querySelector('input[name="rate"]');
          const lastRateBook = lastRow.querySelector('input[name="rateBook"]');
          
          const isFilled = lastOpsInput && lastOpsInput.value.trim() !== "" &&
            lastQty && lastQty.value.trim() !== "" &&
            lastRate && lastRate.value.trim() !== "" &&
            lastRateBook && lastRateBook.value.trim() !== "";
          
          if (!isFilled) {
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = "Please fill Ops Name, Qty / Book, Rate, and Rate / Book before adding a new row.";
              multipleJobsAddOpsWarning.style.color = "#ef4444";
            }
            return;
          }
          
          const clone = lastRow.cloneNode(true);
          
          // Reset values in cloned row
          const opsInput = clone.querySelector('input[name="opsName"]');
          const qtyInput = clone.querySelector('input[name="qtyBook"]');
          const rateInput = clone.querySelector('input[name="rate"]');
          const rateBookInput = clone.querySelector('input[name="rateBook"]');
          
          if (opsInput) {
            opsInput.value = "";
          }
          if (qtyInput) qtyInput.value = "";
          if (rateInput) {
            rateInput.value = "1";
            rateInput.readOnly = true;
          }
          if (rateBookInput) {
            rateBookInput.value = "1";
            rateBookInput.readOnly = true;
          }
          
          multipleJobsAddOpsBody.appendChild(clone);
          
          // Clear warning
          if (multipleJobsAddOpsWarning) multipleJobsAddOpsWarning.textContent = "";
        });
      }
      
      // Save button for common Add New Ops section - saves to all jobs
      if (multipleJobsSaveOpsBtn && multipleJobsAddOpsBody) {
        multipleJobsSaveOpsBtn.addEventListener('click', async () => {
          if (multipleJobs.length === 0) {
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = "Please add at least one job first.";
              multipleJobsAddOpsWarning.style.color = "#ef4444";
            }
            return;
          }
          
          const rows = multipleJobsAddOpsBody.querySelectorAll('.ops-row');
          const operations = [];
          
          // Validate all rows before processing
          for (const row of rows) {
            const opsInput = row.querySelector('input[name="opsName"]');
            const qtyInput = row.querySelector('input[name="qtyBook"]');
            const rateInput = row.querySelector('input[name="rate"]');
            const rateBookInput = row.querySelector('input[name="rateBook"]');
            
            if (opsInput?.value && qtyInput?.value && rateInput?.value && rateBookInput?.value) {
              const opsValue = opsInput.value.trim();
              const operation = findOperationByNameOrId(opsValue);
              
              // Check if operation exists in the list
              if (!operation) {
                if (multipleJobsAddOpsWarning) {
                  multipleJobsAddOpsWarning.textContent = `Operation "${opsValue}" is not in the list. Please select an operation from the list.`;
                  multipleJobsAddOpsWarning.style.color = "#ef4444";
                }
                return; // Stop saving if operation not found
              }
              
              // Validate qty/book based on operation type
              const validation = validateQtyBook(qtyInput.value, operation);
              if (!validation.valid) {
                if (multipleJobsAddOpsWarning) {
                  multipleJobsAddOpsWarning.textContent = validation.message;
                  multipleJobsAddOpsWarning.style.color = "#ef4444";
                }
                return;
              }
              
              // Use operation ID (operation must exist at this point)
              operations.push({
                operationId: operation._id,
                qtyPerBook: parseFloat(qtyInput.value),
                rate: parseFloat(rateInput.value),
                ratePerBook: parseFloat(rateBookInput.value)
              });
            }
          }
          
          if (operations.length === 0) {
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = "Please add at least one operation.";
              multipleJobsAddOpsWarning.style.color = "#ef4444";
            }
            return;
          }
          
          // Save operations to all jobs
          const savePromises = multipleJobs.map(async (jobData) => {
            const extraJobData = {
              clientName: jobData.jobDetails.clientName || '',
              jobTitle: jobData.jobDetails.jobTitle || '',
              qty: jobData.jobDetails.qty || 0,
              productCat: jobData.jobDetails.productCat || '',
              unitPrice: jobData.jobDetails.unitPrice || 0
            };
            
            return jobsAPI.saveJobOpsMaster(jobData.jobNumber, operations, extraJobData);
          });
          
          try {
            await Promise.all(savePromises);
            
            // Save job numbers to Series collection only if not pulled from existing series
            if (!currentSeriesId) {
              const jobNumbers = multipleJobs.map(jobData => jobData.jobNumber);
              try {
                await seriesAPI.create(jobNumbers);
                console.log('Job numbers saved to Series:', jobNumbers);
              } catch (seriesError) {
                console.error('Error saving to Series (non-critical):', seriesError);
                // Don't fail the entire operation if Series save fails
              }
            } else {
              console.log('Skipping series creation - using existing series ID:', currentSeriesId);
            }
            
            // Clear the series ID after save
            currentSeriesId = null;
            
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = "";
            }
            alert(`Operations saved successfully to all ${multipleJobs.length} job(s)!`);
            
            // Clear the entire screen
            // Clear multiple jobs array
            multipleJobs = [];
            
            // Clear multiple jobs container (remove all job rows)
            const multipleJobsContainer = document.getElementById('multipleJobsContainer');
            if (multipleJobsContainer) {
              multipleJobsContainer.innerHTML = '';
            }
            
            // Clear job number input
            if (jobNumberInput) {
              jobNumberInput.value = '';
            }
            
            // Clear Pull in Series checkbox
            const pullInSeriesCheckbox = document.getElementById('pullInSeriesCheckbox');
            if (pullInSeriesCheckbox) {
              pullInSeriesCheckbox.checked = false;
            }
            
            // Clear job search error
            if (jobSearchError) {
              jobSearchError.textContent = '';
              jobSearchError.style.display = 'none';
            }
            
            // Hide job number dropdown
            if (jobNumberDropdown) {
              jobNumberDropdown.style.display = 'none';
            }
            
            // Hide the Add New Ops section
            const multipleJobsAddOpsSection = document.getElementById('multipleJobsAddOpsSection');
            if (multipleJobsAddOpsSection) {
              multipleJobsAddOpsSection.style.display = 'none';
            }
            
            // Reset the add ops table
            multipleJobsAddOpsBody.innerHTML = '';
            const baseRow = document.createElement('tr');
            baseRow.classList.add('ops-row');
            baseRow.innerHTML = `
              <td>
                <input type="text" name="opsName" class="ops-input" list="opsList" placeholder="Type or select ops" autocomplete="off" />
              </td>
              <td>
                <input type="text" name="qtyBook" />
              </td>
              <td>
                <input type="number" name="rate" value="1" readonly />
              </td>
              <td>
                <input type="number" name="rateBook" value="1" readonly />
              </td>
            `;
            multipleJobsAddOpsBody.appendChild(baseRow);
            // Datalist is already populated, no need to do anything
          } catch (error) {
            if (multipleJobsAddOpsWarning) {
              multipleJobsAddOpsWarning.textContent = error.message || 'Failed to save operations to one or more jobs.';
              multipleJobsAddOpsWarning.style.color = "#ef4444";
            }
          }
        });
      }
      
      // Event handlers for ops input and qty input in common Add New Ops section
      if (multipleJobsAddOpsBody) {
        // Handle ops name input
        multipleJobsAddOpsBody.addEventListener('input', (e) => {
          if (e.target && e.target.name === 'opsName') {
            const row = e.target.closest('.ops-row');
            if (row) {
              const opsValue = e.target.value.trim();
              // Validate if operation exists in list
              if (opsValue) {
                const operation = findOperationByNameOrId(opsValue);
                if (!operation) {
                  // Show warning
                  if (multipleJobsAddOpsWarning) {
                    multipleJobsAddOpsWarning.textContent = `"${opsValue}" is not in the operations list. Please select from the list.`;
                    multipleJobsAddOpsWarning.style.color = "#ef4444";
                  }
                } else {
                  // Clear warning if operation is found
                  if (multipleJobsAddOpsWarning && multipleJobsAddOpsWarning.textContent.includes('is not in the operations list')) {
                    multipleJobsAddOpsWarning.textContent = "";
                  }
                }
              } else {
                // Clear warning if field is empty
                if (multipleJobsAddOpsWarning && multipleJobsAddOpsWarning.textContent.includes('is not in the operations list')) {
                  multipleJobsAddOpsWarning.textContent = "";
                }
              }
              
              updateRowPricing(row);
              // Update column header based on entered operations
              updateColumnHeader('multipleJobsAddOpsTable');
            }
          }
          
          // Handle qty input
          if (e.target && e.target.name === 'qtyBook') {
            const row = e.target.closest('.ops-row');
            if (!row) return;
            
            const qtyInput = row.querySelector('input[name="qtyBook"]');
            const rateInput = row.querySelector('input[name="rate"]');
            const rateBookInput = row.querySelector('input[name="rateBook"]');
            
            if (!qtyInput || !rateInput || !rateBookInput) return;
            
            const opsInput = row.querySelector('input[name="opsName"]');
            const opsValue = opsInput ? opsInput.value : null;
            const operation = opsValue
              ? findOperationByNameOrId(opsValue)
              : null;
            
            const qty = qtyInput.value ? parseFloat(qtyInput.value) : 0;
            const rate = rateInput.value ? parseFloat(rateInput.value) : 0;
            
            // Only update rate/book if qty and rate are valid numbers
            if (!isNaN(qty) && !isNaN(rate) && qty > 0) {
              if (operation && operation.type === '1/x') {
                // For 1/x: rate/book = rate * (1 / booksPerOps)
                rateBookInput.value = (rate * (1 / qty)).toFixed(2);
              } else {
                // For 1:1 and 1*x: rate/book = rate * qty
                rateBookInput.value = (qty * rate).toFixed(2);
              }
            } else {
              rateBookInput.value = '';
            }
          }
        });
        
        // Also validate on blur to catch when user leaves the field
        multipleJobsAddOpsBody.addEventListener('blur', (e) => {
          if (e.target && e.target.name === 'opsName') {
            const opsValue = e.target.value.trim();
            if (opsValue) {
              const operation = findOperationByNameOrId(opsValue);
              if (!operation) {
                if (multipleJobsAddOpsWarning) {
                  multipleJobsAddOpsWarning.textContent = `"${opsValue}" is not in the operations list. Please select from the list.`;
                  multipleJobsAddOpsWarning.style.color = "#ef4444";
                }
              }
            }
          }
        }, true);
      }

      // Load operations on page load
      loadOperations();
    </script>
  </body>
  </html>


